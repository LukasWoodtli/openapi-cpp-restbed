{{>licenseInfo}}
{{#operations}}

#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include "{{classname}}.h"

{{#apiNamespaceDeclarations}}
namespace {{this}} {
{{/apiNamespaceDeclarations}}

using namespace {{modelNamespace}};

{{classname}}Exception::{{classname}}Exception(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int {{classname}}Exception::getStatus() const
{
      return m_status;
}
const char* {{classname}}Exception::what() const noexcept
{
    return m_what.c_str();
}

{{classname}}::{{classname}}(int const& port)
  : m_service(std::make_shared<restbed::Service>()),
    m_port(port)
{
}

{{classname}}::~{{classname}}() {}

{{#operation}}
void {{classname}}::set{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource(std::shared_ptr<{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource> sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource) {
        m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource = sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource;
}
{{/operation}}


void {{classname}}::publishResources() {

        {{#operation}}
        if (!m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource)
        m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource = std::make_shared<{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource>();
        m_service->publish(m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource);
        {{/operation}}
}

void {{classname}}::setRootPath(std::string path) {
        m_rootPath = path;
}

std::shared_ptr<restbed::Settings> {{classname}}::createSettings()
{
        std::shared_ptr<restbed::Settings> settings = std::make_shared<restbed::Settings>();
        settings->set_port(m_port);
        settings->set_root(m_rootPath);
        return settings;
}

void {{classname}}::startService() {

        publishResources();
        std::shared_ptr<restbed::Settings> settings = createSettings();

        m_service->start(settings);
}

void {{classname}}::stopService() {
        m_service->stop();
}

{{#operation}}
{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource()
{
	this->set_path("{{path}}");
	this->set_method_handler("{{httpMethod}}",
		std::bind(&{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal, this,
			std::placeholders::_1));
	{{#vendorExtensions.x-codegen-other-methods}}
	this->set_method_handler("{{httpMethod}}",
		std::bind(&{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal, this,
			std::placeholders::_1));
	{{/vendorExtensions.x-codegen-other-methods}}
}

{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::~{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource()
{
}

void {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal(const std::shared_ptr<restbed::Session> session) {

	const auto request = session->get_request();
	{{#hasBodyParam}}
	// Body params are present, therefore we have to fetch them
	int content_length = request->get_header("Content-Length", 0);
	session->fetch(content_length,
		[ this ]( const std::shared_ptr<restbed::Session> session, const restbed::Bytes & body )
		{
			const auto request = session->get_request();
			std::string file = restbed::String::format("%.*s\n", ( int ) body.size( ), body.data( ));
			/**
			 * Get body params or form params here from the file string
			 */
                        {{#allParams}}
                        std::stringstream sstream(file);
                        boost::property_tree::ptree pt;
                        boost::property_tree::json_parser::read_json(sstream,pt);
                        {{#isModel}}
                        auto {{paramName}} = std::make_shared<{{{baseType}}}>(pt);
                        {{#isArray}}
                        auto {{paramName}} = std::make_shared<std::vector<{{{baseType}}}>>();
                        for (const auto& child: pt) {
                          {{paramName}}->emplace_back(std::make_shared<{{{baseType}}}>(child));
                        }
                        {{/isArray}}
                        {{/isModel}}
                        {{/allParams}}
	                {{/hasBodyParam}}

			{{#hasPathParams}}
			// Getting the path params
			{{#pathParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_path_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/pathParams}}
			{{/hasPathParams}}

			{{#hasQueryParams}}
			// Getting the query params
			{{#queryParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_query_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/queryParams}}
			{{/hasQueryParams}}

			{{#hasHeaderParams}}
			// Getting the headers
			{{#headerParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_header("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/headerParams}}
			{{/hasHeaderParams}}

			// Change the value of this variable to the appropriate response before sending the response
			int status_code = 500;
			std::string result = "unknown error";

                        try {
                                std::tie(status_code, result) =
                                    handler_{{httpMethod}}(
                                        {{#allParams}} {{paramName}} {{^-last}},
                                        {{ / -last}} {{ / allParams}});
                        }
                        catch(const {{classname}}Exception& e) {
                                status_code = e.getStatus();
                                result = e.what();
                        }

			{{#responses}}
			if (status_code == {{code}}) {
				{{#headers}}
				// Description: {{description}}
				session->set_header("{{baseName}}", ""); // Change second param to your header value
				{{/headers}}
				session->close({{code}}, result.empty() ? "{{message}}" : std::move(result), { {"Connection", "close"} });
				return;
			}
			{{/responses}}
                        session->close(status_code, result, { {"Connection", "close"} });
                        return;

	{{#hasBodyParam}}
		});
	{{/hasBodyParam}}
}

{{#vendorExtensions.x-codegen-other-methods}}
void {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal(const std::shared_ptr<restbed::Session> session) {

	const auto request = session->get_request();
	{{#hasBodyParam}}
	// Body params are present, therefore we have to fetch them
	int content_length = request->get_header("Content-Length", 0);
	session->fetch(content_length,
		[ this ]( const std::shared_ptr<restbed::Session> session, const restbed::Bytes & body )
		{

			const auto request = session->get_request();
			std::string file = restbed::String::format("%.*s\n", ( int ) body.size( ), body.data( ));
	{{/hasBodyParam}}

			{{#hasPathParams}}
			// Getting the path params
			{{#pathParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_path_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/pathParams}}
			{{/hasPathParams}}

			{{#hasQueryParams}}
			// Getting the query params
			{{#queryParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_query_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/queryParams}}
			{{/hasQueryParams}}

			{{#hasHeaderParams}}
			// Getting the headers
			{{#headerParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_header("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/headerParams}}
			{{/hasHeaderParams}}

			// Change the value of this variable to the appropriate response before sending the response
			int status_code = 500;
			std::string result = "unknown error";

                        try {
                                std::tie(status_code, result) = handler_{{httpMethod}}(
                                    {{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}
                                );
                        }
                        catch(const {{classname}}Exception& e) {
                                status_code = e.getStatus();
                                result = e.what();
                        }

			{{#responses}}
			if (status_code == {{code}}) {
				{{#baseType}}
				std::shared_ptr<{{.}}> response = NULL;
				{{/baseType}}
				{{#headers}}
				// Description: {{description}}
				session->set_header("{{baseName}}", ""); // Change second param to your header value
				{{/headers}}
				session->close({{code}}, result.empty() ? "{{message}}" : std::move(result), { {"Connection", "close"} });
				return;
			}
			{{/responses}}
                        session->close(status_code, result, { {"Connection", "close"} });
                        return;


	{{#hasBodyParam}}
		});
	{{/hasBodyParam}}
}
{{/vendorExtensions.x-codegen-other-methods}}

std::pair<int, std::string> {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}(
        {{#allParams}}{{{dataType}}} const & {{{baseName}}}{{^-last}}, {{/-last}}{{/allParams}}
        )
{
        throw {{classname}}Exception(501, "Not implemented");
}

{{#vendorExtensions.x-codegen-other-methods}}
std::pair<int, std::string> {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}(
        {{#allParams}}{{{dataType}}} const & {{{baseName}}}{{^-last}}, {{/-last}}{{/allParams}}
        )
{
        throw {{classname}}Exception(501, "Not implemented");
}
{{/vendorExtensions.x-codegen-other-methods}}


{{/operation}}

{{#apiNamespaceDeclarations}}
}
{{/apiNamespaceDeclarations}}

{{/operations}}
