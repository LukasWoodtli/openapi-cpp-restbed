{{>licenseInfo}}
{{#operations}}

#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <corvusoft/restbed/uri.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string.hpp>

#include "{{classname}}.h"

{{#apiNamespaceDeclarations}}
namespace {{this}} {
{{/apiNamespaceDeclarations}}

using namespace {{modelNamespace}};

{{classname}}Exception::{{classname}}Exception(int status_code, std::string what)
  : m_status(status_code),
    m_what(what)
{

}
int {{classname}}Exception::getStatus() const
{
      return m_status;
}
const char* {{classname}}Exception::what() const noexcept
{
    return m_what.c_str();
}

{{classname}}::{{classname}}(int const& port)
  : {{classname}}(std::make_shared<restbed::Service>(), std::make_shared<restbed::Settings>())
{
        m_settings->set_port(port);
}

{{classname}}::{{classname}}(std::shared_ptr<restbed::Settings> const& restbedSettings)
  : {{classname}}(std::make_shared<restbed::Service>(), restbedSettings)
{
}

{{classname}}::{{classname}}(std::shared_ptr<restbed::Service> const& restbedService, std::shared_ptr<restbed::Settings> const& restbedSettings)
  : m_service(restbedService),
    m_settings(restbedSettings)
{
}

{{classname}}::~{{classname}}() {}

{{#operation}}
void {{classname}}::set{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource(std::shared_ptr<{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource> sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource) {
        m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource = sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource;
}
{{/operation}}


void {{classname}}::publishResources() {

        {{#operation}}
        if (!m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource)
            m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource = std::make_shared<{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource>();
        m_service->publish(m_sp{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource);
        {{/operation}}
}

void {{classname}}::setRootPath(std::string path) {
        m_rootPath = path;
}

void {{classname}}::startService() {

        publishResources();
        m_settings->set_root(m_rootPath);
        m_service->start(m_settings);
}

void {{classname}}::stopService() {
        m_service->stop();
}

{{#operation}}
{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource()
{
	this->set_path("{{path}}");
	this->set_method_handler("{{httpMethod}}",
		std::bind(&{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal, this,
			std::placeholders::_1));
	{{#vendorExtensions.x-codegen-other-methods}}
	this->set_method_handler("{{httpMethod}}",
		std::bind(&{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal, this,
			std::placeholders::_1));
	{{/vendorExtensions.x-codegen-other-methods}}
}

{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::~{{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource()
{
}

void {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal(const std::shared_ptr<restbed::Session> session) {

	const auto request = session->get_request();
	{{#hasBodyParam}}
	// Body params are present, therefore we have to fetch them
	int content_length = request->get_header("Content-Length", 0);
	session->fetch(content_length,
		[ this ]( const std::shared_ptr<restbed::Session> session, const restbed::Bytes & body )
		{
			const auto request = session->get_request();
			std::string file_ = restbed::String::format("%.*s\n", ( int ) body.size( ), body.data( ));
			/**
			 * Get body params or form params here from the file string
			 */
                        {{#allParams}}
                        {{#isModel}}
                        std::stringstream {{paramName}}_sstream(file_);
                        boost::property_tree::ptree {{paramName}}_pt;
                        boost::property_tree::json_parser::read_json({{paramName}}_sstream, {{paramName}}_pt);
                        auto {{paramName}} = std::make_shared<{{{baseType}}}>({{paramName}}_pt);
                        {{/isModel}}
                        {{#isArray}}
                        std::stringstream {{paramName}}_sstream(file_);
                        boost::property_tree::ptree {{paramName}}_pt;
                        boost::property_tree::json_parser::read_json({{paramName}}_sstream, {{paramName}}_pt);
                        auto {{paramName}} = {{{dataType}}}();
                        for (const auto& child: {{paramName}}_pt) {
                              {{paramName}}.emplace_back(std::make_shared<{{{baseType}}}>(child.second));
                        }
                        {{/isArray}}
                        {{/allParams}}
	                {{/hasBodyParam}}

			{{#hasPathParams}}
			// Getting the path params
			{{#pathParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_path_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/pathParams}}
			{{/hasPathParams}}

			{{#hasQueryParams}}
			// Getting the query params
			{{#queryParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_query_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
                        {{#isContainer}}
                        std::string {{{paramName}}}_string = request->get_query_parameter("{{paramName}}", "");
                        {{{dataType}}} {{{paramName}}};
                        boost::split({{{paramName}}}, {{{paramName}}}_string, boost::is_any_of(",;"));
                        {{/isContainer}}
			{{/queryParams}}
			{{/hasQueryParams}}

			{{#hasHeaderParams}}
			// Getting the headers
			{{#headerParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_header("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/headerParams}}
			{{/hasHeaderParams}}

			// Change the value of this variable to the appropriate response before sending the response
			int status_code = 500;
                        {{#returnType}}
                        {{{.}}} resultObject = {{{defaultResponse}}};
                        {{/returnType}}
                        std::string result = "";

                        try {
                              {{#returnType}}
                              std::tie(status_code, resultObject) =
                              {{/returnType}}
                              {{^returnType}}
                              status_code =
                              {{/returnType}}
                                      handler_{{httpMethod}}(
                                              {{#allParams}} {{paramName}} {{^-last}},
                                              {{ / -last}} {{ / allParams}});
                        }
                        catch(const {{classname}}Exception& e) {
                                status_code = e.getStatus();
                                result = e.what();
                        }

			{{#responses}}
			if (status_code == {{code}}) {
                                {{#returnType}}
                                {{#isModel}}
                                {{#isString}}
                                result = resultObject;
                                {{/isString}}
                                {{^isString}}
                                result = resultObject->toJsonString();
                                {{/isString}}
                                {{/isModel}}
                                {{#isMap}}
                                boost::property_tree::ptree pt;
                                for(const auto &kv: resultObject) {
                                        pt.push_back(boost::property_tree::ptree::value_type(
                                              boost::lexical_cast<std::string>(kv.first),
                                              boost::property_tree::ptree(
                                                        boost::lexical_cast<std::string>(kv.second))));
                                }
                                std::stringstream sstream;
                                write_json(sstream, pt);
                                result = sstream.str();
                                {{/isMap}}
                                {{/returnType}}
				{{#headers}}
				// Description: {{description}}
				session->set_header("{{baseName}}", ""); // Change second param to your header value
				{{/headers}}
				session->close({{code}}, result.empty() ? "{{message}}" : std::move(result), { {"Connection", "close"} });
				return;
			}
			{{/responses}}
                        session->close(status_code, result, { {"Connection", "close"} });
                        return;

	{{#hasBodyParam}}
		});
	{{/hasBodyParam}}
}

{{#vendorExtensions.x-codegen-other-methods}}
// x-extension
void {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}_internal(const std::shared_ptr<restbed::Session> session) {

	const auto request = session->get_request();
	{{#hasBodyParam}}
	// Body params are present, therefore we have to fetch them
	int content_length = request->get_header("Content-Length", 0);
	session->fetch(content_length,
		[ this ]( const std::shared_ptr<restbed::Session> session, const restbed::Bytes & body )
		{

			const auto request = session->get_request();
                        std::string file_ = restbed::String::format("%.*s\n", ( int ) body.size( ), body.data( ));
                        {{#allParams}}
                        std::stringstream sstream(file_);
                  {{#allParams}}
                  {{#isModel}}
                  std::stringstream {{paramName}}_sstream(file_);
                  boost::property_tree::ptree {{paramName}}_pt;
                  boost::property_tree::json_parser::read_json({{paramName}}_sstream, {{paramName}}_pt);
                  auto {{paramName}} = std::make_shared<{{{baseType}}}>({{paramName}}_pt);
                  {{/isModel}}
                  {{#isArray}}
                  std::stringstream {{paramName}}_sstream(file_);
                  boost::property_tree::ptree {{paramName}}_pt;
                  boost::property_tree::json_parser::read_json({{paramName}}_sstream, {{paramName}}_pt);
                  auto {{paramName}} = {{{dataType}}}();
                  for (const auto& child: {{paramName}}_pt) {
                        {{paramName}}.emplace_back(std::make_shared<{{{baseType}}}>(child));
                  }
                  {{/isArray}}
                  {{^isModel}}
                  {{^isArray}}
                  auto {{paramName}} = std::make_shared<{{{baseType}}}>(file_);
                  {{/isArray}}
                  {{/isModel}}
                  {{/allParams}}
                        {{/allParams}}
	{{/hasBodyParam}}

			{{#hasPathParams}}
			// Getting the path params
			{{#pathParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_path_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/pathParams}}
			{{/hasPathParams}}

			{{#hasQueryParams}}
			// Getting the query params
			{{#queryParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_query_parameter("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/queryParams}}
			{{/hasQueryParams}}

			{{#hasHeaderParams}}
			// Getting the headers
			{{#headerParams}}
			{{#isPrimitiveType}}
			const {{{dataType}}} {{{paramName}}} = request->get_header("{{paramName}}", {{{defaultValue}}});
			{{/isPrimitiveType}}
			{{/headerParams}}
			{{/hasHeaderParams}}

			// Change the value of this variable to the appropriate response before sending the response
			int status_code = 500;
                        {{#returnType}}
                        {{{.}}} resultObject = {{{defaultResponse}}};
                        {{/returnType}}
			std::string result = "";

                        try {
                                {{#returnType}}
                                std::tie(status_code, resultObject) =
                                {{/returnType}}
                                {{^returnType}}
                                status_code =
                                {{/returnType}}
                                        handler_{{httpMethod}}(
                                                  {{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}
                                              );
                        }
                        catch(const {{classname}}Exception& e) {
                                status_code = e.getStatus();
                                result = e.what();
                        }

			{{#responses}}
			if (status_code == {{code}}) {
                                {{#returnType}}
                                {{#isModel}}
                                result = resultObject->toJsonString();
                                {{/isModel}}
                                {{#isMap}}
                                boost::property_tree::ptree pt;
                                for(const auto &kv: resultObject) {
                                        pt.push_back(boost::property_tree::ptree::value_type(
                                                  boost::lexical_cast<std::string>(kv.first),
                                                  boost::property_tree::ptree(
                                                            boost::lexical_cast<std::string>(kv.second))));
                                }
                                std::stringstream sstream;
                                write_json(sstream, pt);
                                result = sstream.str();
                                {{/isMap}}
                                {{/returnType}}
				{{#headers}}
				// Description: {{description}}
				session->set_header("{{baseName}}", ""); // Change second param to your header value
				{{/headers}}
				session->close({{code}}, result.empty() ? "{{message}}" : std::move(result), { {"Connection", "close"} });
				return;
			}
			{{/responses}}
                        session->close(status_code, result, { {"Connection", "close"} });
                        return;


	{{#hasBodyParam}}
		});
	{{/hasBodyParam}}
}
{{/vendorExtensions.x-codegen-other-methods}}

{{#returnType}}std::pair<int, {{{.}}}>{{/returnType}}{{^returnType}}int{{/returnType}} {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}(
        {{#allParams}}{{{dataType}}} const & {{{baseName}}}{{^-last}}, {{/-last}}{{/allParams}}
        )
{
        throw {{classname}}Exception(501, "Not implemented");
}

{{#vendorExtensions.x-codegen-other-methods}}
{{#returnType}}std::pair<int, {{{.}}}>{{/returnType}}{{^returnType}}int{{/returnType}} {{classname}}{{vendorExtensions.x-codegen-resource-name}}Resource::handler_{{httpMethod}}(
        {{#allParams}}{{{dataType}}} const & {{{baseName}}}{{^-last}}, {{/-last}}{{/allParams}}
        )
{
        throw {{classname}}Exception(501, "Not implemented");
}
{{/vendorExtensions.x-codegen-other-methods}}


{{/operation}}

{{#apiNamespaceDeclarations}}
}
{{/apiNamespaceDeclarations}}

{{/operations}}
